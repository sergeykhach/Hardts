{
  "language": "Solidity",
  "sources": {
    "contracts/Demo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n//ay es contracti hamar menq governence enq anelu , sran enq karavarelu\n//aysinqn bolor haraberutyunnery u txnery ays kontracti het anelu enq voch te ughaki ayl governancov\n\ncontract Demo {\n  string public message;\n  mapping(address => uint) public balances;\n  address public owner;\n\n  constructor() {\n    owner = msg.sender;\n  }\n//ownery karuma tal contracty _to in\n  function transferOwnership(address _to) external {\n    require(msg.sender == owner);\n    owner = _to;\n  }\n\n  function pay(string calldata _message) external payable {\n    require(msg.sender == owner);\n    message = _message;\n    balances[msg.sender] = msg.value;\n  }\n}\n"
    },
    "contracts/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\n\ncontract ERC20 is IERC20 {\n    uint totalTokens;\n    address owner;\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowances;\n    string _name;\n    string _symbol;\n\n    modifier enoughTokens(address _from, uint _amount) {\n        require(balanceOf(_from) >= _amount, \"not enough tokens!\");\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"not an owner!\");\n        _;\n    }\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint initialSupply\n    ) {\n        _name = name_;\n        _symbol = symbol_;\n        owner = msg.sender;\n        mint(initialSupply, owner);\n    }\n\n    function name() public view returns(string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns(string memory) {\n        return _symbol;\n    }\n\n    function decimals() public pure returns(uint) {\n        return 18;\n    }\n\n    function totalSupply() public view returns(uint) {\n        return totalTokens;\n    }\n\n    function balanceOf(address account) public view returns(uint) {\n        return balances[account];\n    }\n\n    function transfer(address to, uint amount) external enoughTokens(msg.sender, amount) {\n        _beforeTokenTransfer(msg.sender, to, amount);\n\n        balances[msg.sender] -= amount;\n        balances[to] += amount;\n\n        emit Transfer(msg.sender, to, amount);\n    }\n\n    function allowance(address _owner, address spender) external view returns(uint) {\n        return allowances[_owner][spender];\n    }\n\n    function approve(address spender, uint amount) external {\n        allowances[msg.sender][spender] = amount;\n\n        emit Approve(msg.sender, spender, amount);\n    }\n\n    function transferFrom(address sender, address recipient, uint amount) external {\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        allowances[sender][msg.sender] -= amount;\n        balances[sender] -= amount;\n        balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function mint(uint amount, address _to) public onlyOwner {\n        _beforeTokenTransfer(address(0), _to, amount);\n\n        balances[_to] += amount;\n        totalTokens += amount;\n\n        emit Transfer(address(0), _to, amount);\n    }\n\n    function burn(address _from, uint _amount) public onlyOwner enoughTokens(_from, _amount) {\n        _beforeTokenTransfer(_from, address(0), _amount);\n\n        balances[_from] -= _amount;\n        totalTokens -= _amount;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint amount\n    ) internal virtual {}\n}"
    },
    "contracts/Governance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport './IERC20.sol'; //petqa vor token enq unenum vory priyazka enq anum golosi hamar\n\ncontract Governance {\n    struct ProposalVote { //pahum en qgolosiu ardyunqnery\n        uint againstVotes; //dem\n        uint forVotes; //koghm\n        uint abstainVotes; //dzernpah\n        mapping(address => bool) hasVoted; //konkret hascen golos arel a te che\n    }\n\n    struct Proposal { // es el erb a sksum erb avartvum avartvac a te che\n        uint votingStarts;\n        uint votingEnds;\n        bool executed;\n    }\n//stati vichaknerna\n    enum ProposalState { Pending, Active, Succeeded, Defeated, Executed } // chi sksvac, sksvac a , hajogha.... Executed-pritvoreno v jizn\n\n    mapping(bytes32 => Proposal) public proposals; //Idneri hamarnerov arajarknerov\n    mapping(bytes32 => ProposalVote) public proposalVotes; //golosneri informacian\n\n    IERC20 public token;\n    uint public constant VOTING_DELAY = 10; //jamanak \n    uint public constant VOTING_DURATION = 60; //karch a shat ughaki dem-i hamar\n\n    event ProposalAdded(bytes32 proposalId);\n\n    constructor(IERC20 _token) {\n        token = _token; //asum enq es token a golos-i hamar\n    }\n\n//arajark nerkayacnelu funkcian golosi hamar\n    function propose(\n        address _to, //ur enq ugharkum\n        uint _value, //poghi chapy\n        string calldata _func,\n        bytes calldata _data, //tvyalnery vor uzum enq ugharkel\n        string calldata _description //arajarki eutyuny\n    ) external returns(bytes32) {\n        require(token.balanceOf(msg.sender) > 0, \"not enough tokens\"); //ov uni kara golos uni\n\n        bytes32 proposalId = generateProposalId(// arajarki ID-n vor imananq konkret vior arajarki hamar en qgolos anum\n            _to, _value, _func, _data, keccak256(bytes(_description))//discr-y hash enq anum\n        );\n\n        require(proposals[proposalId].votingStarts == 0, \"proposal already exists\"); //nuyn banery petq chi lini\n\n        proposals[proposalId] = Proposal({\n            votingStarts: block.timestamp + VOTING_DELAY,//erba sksum\n            votingEnds: block.timestamp + VOTING_DELAY + VOTING_DURATION,// erba avartvum\n            executed: false //avartvel a ? default\n        });\n\n        emit ProposalAdded(proposalId);\n\n        return proposalId;\n    }\n\n//asum  inq irakanacra progolosovani haghtac proposaly\n    function execute(\n        address _to, //mihat ek nuyn banery\n        uint _value,\n        string calldata _func,\n        bytes calldata _data,\n        bytes32 _descriptionHash// nkaragrutyan hash\n    ) external returns(bytes memory) {\n        bytes32 proposalId = generateProposalId( //asum enq vor irakanum eghela senc proposal u golosa eghel\n            _to, _value, _func, _data, _descriptionHash\n        );\n\n        require(state(proposalId) == ProposalState.Succeeded, \"invalid state\");//hajogha eghel\n\n        Proposal storage proposal = proposals[proposalId];\n\n        proposal.executed = true; \n\n        bytes memory data;\n        if (bytes(_func).length > 0) { //asum enq ete _func ka  uremn\n            data = abi.encodePacked( // apa ed funkciayi anuny hash enq anum u\n                bytes4(keccak256(bytes(_func))), _data //vercnum enq arajin 4 byte\n            );\n        } else {\n            data = _data; // hakarak depqum inch ka\n        }\n\n        (bool success, bytes memory resp) = _to.call{value: _value}(data);\n        require(success, \"tx failed\"); //ugharkumenq nizko urovni\n\n        return resp; \n    }\n\n//inchpes golos anennq\n    function vote(bytes32 proposalId, uint8 voteType) external {\n        require(state(proposalId) == ProposalState.Active, \"invalid state\");//asum enq pti state aktiv lini\n\n        uint votingPower = token.balanceOf(msg.sender);// parz realizacia hzorutyan ysk tokenneri qanaki vortev, kara ira mi hasceyic myus gci au amen angam hzor golos ani, dra hamar zep-um jamanaki koncept ka check point\n\n        require(votingPower > 0, \"not enough tokens\");// asum enq gone mi qich token pti unenas \n\n        ProposalVote storage proposalVote = proposalVotes[proposalId];//id-ov gtnum  enq proposaly vor vote anenq\n\n        require(!proposalVote.hasVoted[msg.sender], \"already voted\");//asum enq vor mi angam voted ani\n\n        if(voteType == 0) { //asum enq ete 0ya urmen dema \n            proposalVote.againstVotes += votingPower; // u avelacnum enq yst dra\n        } else if(voteType == 1) {//1 a uremn koghma \n            proposalVote.forVotes += votingPower;\n        } else {\n            proposalVote.abstainVotes += votingPower;\n        }\n\n        proposalVote.hasVoted[msg.sender] = true;//asum enq vor arden golos arel a\n    }\n\n//stugum enq ardyoq golosovaniyan sksel a\n    function state(bytes32 proposalId) public view returns (ProposalState) {\n        Proposal storage proposal = proposals[proposalId];\n        ProposalVote storage proposalVote = proposalVotes[proposalId];\n//stugum enq ka te che tenc arajark\n        require(proposal.votingStarts > 0, \"proposal doesnt exist\");\n\n        if (proposal.executed) {\n            return ProposalState.Executed;\n        }//arden arvac\n\n        if (block.timestamp < proposal.votingStarts) {\n            return ProposalState.Pending;\n        }//hly chi skasac\n\n        if(block.timestamp >= proposal.votingStarts &&\n            proposal.votingEnds > block.timestamp) {\n            return ProposalState.Active;\n        }//yntacqi mej a\n\n        //stegh karanq qvorum i mekhanizm dneinq\n        if(proposalVote.forVotes > proposalVote.againstVotes) {\n            return ProposalState.Succeeded;\n        } else {\n            return ProposalState.Defeated;\n        }//prcela kam yndunvela ka voch\n    }\n\n//esi henc konkret arajarki Id-n enq generacnum\n    function generateProposalId(\n        address _to,\n        uint _value,\n        string calldata _func,\n        bytes calldata _data,\n        bytes32 _descriptionHash\n    ) internal pure returns(bytes32) {\n        return keccak256(abi.encode(\n            _to, _value, _func, _data, _descriptionHash\n        ));\n    }\n\n    receive() external payable {}\n}\n\n"
    },
    "contracts/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function name() external view returns(string memory);\n\n    function symbol() external view returns(string memory);\n\n    function decimals() external pure returns(uint);\n\n    function totalSupply() external view returns(uint);\n\n    function balanceOf(address account) external view returns(uint);\n\n    function transfer(address to, uint amount) external;\n\n    function transferFrom(address sender, address recipient, uint amount) external;\n\n    function allowance(address owner, address spender) external view returns(uint);\n\n    function approve(address spender, uint amount) external;\n\n    event Transfer(address indexed from, address indexed to, uint amount);\n    event Approve(address indexed owner, address indexed to, uint amount);\n}\n"
    },
    "contracts/MyToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ERC20.sol\";\n//es tokennel ogtagorcvelu a golosavaniya hamar ov uni kara golos ani, yst hzorutyan yst qanki\ncontract MyToken is ERC20 {\n  constructor() ERC20(\"MyToken\", \"MTK\", 1000) {}\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}